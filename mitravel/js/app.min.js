let ua = window.navigator.userAgent;
let isMobile = {
  Android: function () {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function () {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function () {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Opera: function () {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function () {
    return navigator.userAgent.match(/IEMobile/i);
  },
  any: function () {
    return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
  }
};

function isIE() {
  ua = navigator.userAgent;
  let is_ie = ua.indexOf("MSIE ") > -1 || ua.indexOf("Trident/") > -1;
  return is_ie;
}
if (isIE()) {
  document.querySelector('body').classList.add('ie');
}
if (isMobile.any()) {
  document.querySelector('body').classList.add('touch');
}


// IBG

function ibg() {
  if (isIE()) {
    let ibg = document.querySelectorAll(".ibg");
    for (var i = 0; i < ibg.length; i++) {
      if (ibg[i].querySelector('img') && ibg[i].querySelector('img').getAttribute('src') != null) {
        ibg[i].style.backgroundImage = 'url(' + ibg[i].querySelector('img').getAttribute('src') + ')';
      }
    }
  }
}
ibg();

const menu = document.querySelector('.menu'),
  burger = document.querySelector('.burger'),
  close = document.querySelector('.menu__close');

burger.addEventListener('click', function() {
  menu.classList.add('menu--visible');
  disableScroll();
});

close.addEventListener('click', function() {
  menu.classList.remove('menu--visible');
  enableScroll();
});

// Отклюбчения "прыжка" сайта при открытии меню
const fixBlocks = document.querySelectorAll('._fix-block');
const body = document.body;

let disableScroll = function() {
  let paddingOffset = window.innerWidth - body.offsetWidth + 'px';
  let pagePosition = window.scrollY;
  fixBlocks.forEach(function(el) {
    el.style.paddingRight = paddingOffset;
  });
  body.style.paddingRight = paddingOffset;
  body.classList.add('_lock');
  body.dataset.position = pagePosition;
  body.style.top = -pagePosition + 'px';
};

let enableScroll = function() {
  let pagePosition = parseInt(body.dataset.position, 10);
  body.style.top = 'auto';
  body.classList.remove('_lock');
  fixBlocks.forEach(function(el) {
    el.style.paddingRight = '0px';
  });
  body.style.paddingRight = '0px';
  window.scroll({ top: pagePosition, left: 0 });
  body.removeAttribute('data-position');
};
const swiperHero = document.querySelector('.main-slider .swiper-container'),
  swiperBecome = document.querySelector('.slider-become .swiper-container'),
  swiperVideos = document.querySelector('.slider-videos .swiper-container');

// Slider 1
const swiper1 = new Swiper(swiperHero, {
  keyboard: {
    enabled: true,
  },
  speed: 1000,
  slidesPerView: 1,
  fadeEffect: {
    crossFade: true
  },
  effect: 'fade',
  navigation: {
    nextEl: '.main-slider__btn--left',
    prevEl: '.main-slider__btn--right',
  },
});

// Отключение видео
swiper1.on('transitionEnd', function() {
  let videos = document.querySelectorAll('.main-slider video');
  videos.forEach(function(el) {
    el.pause();
    el.currentTime = 0;
  });
  playButtonsMain.forEach(function(el) {
    el.style.display = 'block';
  });
});

// ========================================================================
// Slider 2
const swiper2 = new Swiper(swiperBecome, {
  keyboard: {
    enabled: true,
  },
  speed: 1000,
  slidesPerView: 4,
  // Responsive breakpoints
  breakpoints: {
    // when window width is >= 320px
    320: {
      slidesPerView: 1,
    },
    480: {
      slidesPerView: 2,
    },
    768: {
      slidesPerView: 3,
    },
    992: {
      slidesPerView: 4,
    }
  }
});

// ========================================================================
// Slider 3
const swiper3 = new Swiper(swiperVideos, {
  centeredSlides: true,
  spaceBetween: 105,
  loop: true,
  keyboard: {
    enabled: true,
  },
  speed: 1000,
  slidesPerView: 'auto'
});

// Отключение видео
swiper3.on('transitionEnd', function () {
  let videos = document.querySelectorAll('.slider-videos video');
  videos.forEach(function (el) {
    el.pause();
    el.currentTime = 0;
  });
  playButtonsFeaturedVideo.forEach(function (el) {
    el.style.display = 'block';
    el.closest('.slider-videos__item').querySelector('.slider-videos__title').style.display = 'block';
  });
});
const playButtonsMain = document.querySelectorAll('.main-slider__play-video'),
  playButtonsFeaturedVideo = document.querySelectorAll('.slide-play');

// Видео в секции hero
playButtonsMain.forEach(function(el) {
  el.addEventListener('click', function(e) {
    let video = e.currentTarget.closest('.main-slider__media').querySelector('video');
    video.play();
    e.currentTarget.style.display = 'none';
    setTimeout(function() {
      video.volume = 0.5;
    }, 1000);
  });
});

// Видео в секции featured-videos
playButtonsFeaturedVideo.forEach(function(el) {
  el.addEventListener('click', function(e) {
    let video = e.currentTarget.closest('.slider-videos__item').querySelector('video');
    video.play();
    e.currentTarget.style.display = 'none';
    let title = e.currentTarget.closest('.slider-videos__item').querySelector('.slider-videos__title');
    title.style.display = 'none';
    setTimeout(function() {
      video.volume = 0.5;
    }, 1000);
  });
});

// Найдем и объявим в переменную все элементы, которые будут поддаваться анимации
const animItems = document.querySelectorAll('._anim-items');

// Проверю, существуют ли такие классы
if (animItems.length > 0) {
  
  window.addEventListener('scroll', animOnScroll);

  function animOnScroll() {
    // Пройдемся циклом по массиву и каждый объект объявить в переменную animItem
    for (let index = 0; index < animItems.length; index++) {
      const animItem = animItems[index];
      // Высота объекта
      const animItemHeight = animItem.offsetHeight;
      // Позиция объекта относительно верха страницы
      const animItemOffset = offset(animItem).top;
      // Коефицент, регулирующий момент старта анимации
      const animStart = 4;

      // Высчитаем высоту окна браузера. Из высоты окна браузера отнимаем высоту объекта, который анимируется, поделенный на коэфицент
      let animItemPoint = window.innerHeight - animItemHeight / animStart;

      // Иногда анимированный объект выше высоты окна браузера, по этому запишем условие:
      // Если высота объекта выше высоты окна браузера, то
      if (animItemHeight > window.innerHeight) {
        // Из высоты окна браузера отнимаем высоту окна браузера, поделенный на коэфицент
        animItemPoint = window.innerHeight - window.innerHeight / animStart;
      }

      // Добавляем активный класс
      // Если мы прокрутили больше чем позиция объекта минус точка старта, И прокрутили меньше чем позиция объекта плюс его высота
      if ((pageYOffset > animItemOffset - animItemPoint) && pageYOffset < (animItemOffset + animItemHeight)) {
        // Мы добавляем к объекту класс active
        animItem.classList.add('_active');
      } else {
        // Если у объекта нет класса ._anim-no-hide
        if (!animItem.classList.contains('_anim-no-hide')) {
          // Удаляем у объекта класс active, если не выполняется условие
          animItem.classList.remove('_active');
        }
      }
    }
  }

  // Корректная и кроссбраузерная функция, позволяющая получать переменные с координатами относительно документа (top, left)
  function offset(el) {
    const rect = el.getBoundingClientRect(),
      scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
      scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
  }

  // Установим задержку функции
  setTimeout(() => {
    animOnScroll();
  }, 300);

}
// Получаю в переменную массив обэектов с классом .popup-link
const popupLinks = document.querySelectorAll('.popup-link');
// Получаю в переменную объект body, нужный для блокировки скролла внутри него
// const body = document.querySelector('body'); // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Получаю массив объектов с классом .lock-padding, нужные для того чтобы ...
const lockPadding = document.querySelectorAll('.lock-padding');

// Отключение двойных нажатий
let unlock = true;

// Задержка анимации, задержка должна быть одинаковой, как прописанна в свойстве transition
const timeout = 800;

// Проверяем существуют ли объекты с классом .popup-link
if (popupLinks.length > 0) {
  // Проходим циклом, и тукущий объект массива, объявляем в переменную popupLink
  for (let index = 0; index < popupLinks.length; index++) {
    const popupLink = popupLinks[index];
    // Вешаем обработчик события по клику, на кнопку
    popupLink.addEventListener('click', function(e) {
      // Берем значение атрибута href, убираем из него символ хеша, получаем чистое имя
      const popupName = popupLink.getAttribute('href').replace('#', ''); // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // Получаем объект попапа в переменную curentPopup, id которого равен popupName
      const curentPopup = document.getElementById(popupName);
      // Полученный объект направляем в функцию popupOpen, которая будет открывать попап
      popupOpen(curentPopup);
      // Отмена стандартного действия ссылки. Не дадим ей перезагружать страницу
      e.preventDefault();
    });
  }
}

// Функция закрытия попапа
// Получаю в переменную массив объектов с классом .close-popup, которые есть в попапах
const popupCloseIcon = document.querySelectorAll('.close-popup');
if (popupCloseIcon.length > 0) {
  for (let index = 0; index < popupCloseIcon.length; index++) {
    const el = popupCloseIcon[index];
    // На текущий закрывающий элемент вешаем обработчик события по клику
    el.addEventListener('click', function(e) {
      // Передадим в функцию popupClose, объект, который является ближайшим родителем с классом .popup, нажатой ссылки
      popupClose(el.closest('.popup'));
      // Отмена стандартного действия ссылки. Не дадим ей перезагружать страницу
      e.preventDefault();
    });
  }
}

// Функция открытия попапа
// Передаем в функцию тукущий попап
function popupOpen(curentPopup) {
  // Проверяем есть ли такой объект и открыта ли переменная unlock
  if (curentPopup && unlock) {
    // Получаем объект с классом .popup который имеет класс .open, тоесть открытый попап
    const popupActive = document.querySelector('.popup.open');
    // Если он существует
    if (popupActive) {
      // Закрыть его
      popupClose(popupActive, false);
    } else {
      // Блокируем скролл у body
      bodyLock();
    }
    // Добавляем попапу класс .open
    curentPopup.classList.add('open');
    // Вешаем событие на текуший попап по клику
    curentPopup.addEventListener('click', function (e) {
      // Этим условием отсекаем все, кроме темной оьласти
      // Идет проверка, если у нажатого объекта нет в родителях объекта с классом .popup__content
      if (!e.target.closest('.popup__content')) {
        // Тогда попап закрываем, передавая наш ближайший объект с классом .popup
        popupClose(e.target.closest('.popup'));
      }
    });
  }
}

// Функция закрытия окна
function popupClose(popupActive, doUnlock = true) {
  if (unlock) {
    popupActive.classList.remove('open');
    if (doUnlock) {
      bodyUnLock();
    }
  }
}

// 
function bodyLock() {
  const lockPaddingValue = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';

  for (let index = 0; index < lockPadding.length; index++) {
    const el = lockPadding[index];
    el.style.paddingRight = lockPaddingValue;
  }
  body.style.paddingRight = lockPaddingValue;
  body.classList.add('lock');

  unlock = false;
  setTimeout(function() {
    unlock = true;
  }, timeout);
}





//=================
//Popups
let popup_link = document.querySelectorAll('._popup-link');
let popups = document.querySelectorAll('.popup');

for (let index = 0; index < popup_link.length; index++) {
  const el = popup_link[index];
  el.addEventListener('click', function (e) {
    if (unlock) {
      let item = el.getAttribute('href').replace('#', '');
      let video = el.getAttribute('data-video');
      popup_open(item, video);
    }
    e.preventDefault();
  })
}

for (let index = 0; index < popups.length; index++) {
  const popup = popups[index];
  popup.addEventListener("click", function (e) {
    if (!e.target.closest('.popup__body')) {
      popup_close(e.target.closest('.popup'));
    }
  });
}

function popup_open(item, video = '') {
  let activePopup = document.querySelectorAll('.popup._active');
  if (activePopup.length > 0) {
    popup_close('', false);
  }
  let curent_popup = document.querySelector('.popup_' + item);
  if (curent_popup && unlock) {
    if (video != '' && video != null) {
      let popup_video = document.querySelector('.popup_video');
      popup_video.querySelector('.popup__video').innerHTML = '<iframe src="https://www.youtube.com/embed/' + video + '?autoplay=1"  allow="autoplay; encrypted-media" allowfullscreen></iframe>';
    }
    if (!document.querySelector('.menu__body._active')) {
      body_lock_add(500);
    }
    curent_popup.classList.add('_active');
    history.pushState('', '', '#' + item);
  }
}

function popup_close(item, bodyUnlock = true) {
  if (unlock) {
    if (!item) {
      for (let index = 0; index < popups.length; index++) {
        const popup = popups[index];
        let video = popup.querySelector('.popup__video');
        if (video) {
          video.innerHTML = '';
        }
        popup.classList.remove('_active');
      }
    } else {
      let video = item.querySelector('.popup__video');
      if (video) {
        video.innerHTML = '';
      }
      item.classList.remove('_active');
    }
    if (!document.querySelector('.menu__body._active') && bodyUnlock) {
      body_lock_remove(500);
    }
    history.pushState('', '', window.location.href.split('#')[0]);
  }
}

let popup_close_icon = document.querySelectorAll('.popup__close,._popup-close');
if (popup_close_icon) {
  for (let index = 0; index < popup_close_icon.length; index++) {
    const el = popup_close_icon[index];
    el.addEventListener('click', function () {
      popup_close(el.closest('.popup'));
    })
  }
}

document.addEventListener('keydown', function (e) {
  if (e.which == 27) {
    popup_close();
  }
});
/* //= './functions/forms.js' */